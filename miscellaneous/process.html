<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>网络篇 | 亿个本子</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="apple-touch-icon" sizes="180x180" href="/archived/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" href="/archived/favicon/favicon-16x16.png">
    <link rel="icon" type="image/png" href="/archived/favicon/favicon-32x32.png">
    <link rel="manifest" href="/archived/favicon/site.webmanifest">
    <meta name="description" content="frontend related notes">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="preload" href="/archived/assets/css/0.styles.44ae0491.css" as="style"><link rel="preload" href="/archived/assets/js/app.8b58d644.js" as="script"><link rel="preload" href="/archived/assets/js/2.bf33e473.js" as="script"><link rel="preload" href="/archived/assets/js/31.22830e2f.js" as="script"><link rel="prefetch" href="/archived/assets/js/10.08eb2b05.js"><link rel="prefetch" href="/archived/assets/js/11.8af729f7.js"><link rel="prefetch" href="/archived/assets/js/12.89a362e4.js"><link rel="prefetch" href="/archived/assets/js/13.333ebb92.js"><link rel="prefetch" href="/archived/assets/js/14.fecca8fb.js"><link rel="prefetch" href="/archived/assets/js/15.d74cca93.js"><link rel="prefetch" href="/archived/assets/js/16.33b6a90d.js"><link rel="prefetch" href="/archived/assets/js/17.a8d0bc73.js"><link rel="prefetch" href="/archived/assets/js/18.99e676ac.js"><link rel="prefetch" href="/archived/assets/js/19.8f4f6bc7.js"><link rel="prefetch" href="/archived/assets/js/20.b60b2514.js"><link rel="prefetch" href="/archived/assets/js/21.1409a82a.js"><link rel="prefetch" href="/archived/assets/js/22.0f7af644.js"><link rel="prefetch" href="/archived/assets/js/23.24d2717c.js"><link rel="prefetch" href="/archived/assets/js/24.1f557f08.js"><link rel="prefetch" href="/archived/assets/js/25.6d9fa012.js"><link rel="prefetch" href="/archived/assets/js/26.0c4a868e.js"><link rel="prefetch" href="/archived/assets/js/27.4452b985.js"><link rel="prefetch" href="/archived/assets/js/28.f467e649.js"><link rel="prefetch" href="/archived/assets/js/29.13e49743.js"><link rel="prefetch" href="/archived/assets/js/3.9903a5d7.js"><link rel="prefetch" href="/archived/assets/js/30.f8890062.js"><link rel="prefetch" href="/archived/assets/js/32.9945a466.js"><link rel="prefetch" href="/archived/assets/js/33.8354ffb2.js"><link rel="prefetch" href="/archived/assets/js/34.b80b6b78.js"><link rel="prefetch" href="/archived/assets/js/35.b5435a07.js"><link rel="prefetch" href="/archived/assets/js/36.6eb06aac.js"><link rel="prefetch" href="/archived/assets/js/37.78e82f4a.js"><link rel="prefetch" href="/archived/assets/js/38.bae8bf11.js"><link rel="prefetch" href="/archived/assets/js/39.61fc07c0.js"><link rel="prefetch" href="/archived/assets/js/4.45587ab2.js"><link rel="prefetch" href="/archived/assets/js/40.4ff96977.js"><link rel="prefetch" href="/archived/assets/js/41.24669c96.js"><link rel="prefetch" href="/archived/assets/js/42.c40fcb14.js"><link rel="prefetch" href="/archived/assets/js/43.77267e49.js"><link rel="prefetch" href="/archived/assets/js/44.684a4efa.js"><link rel="prefetch" href="/archived/assets/js/45.ec35426d.js"><link rel="prefetch" href="/archived/assets/js/46.9af30f73.js"><link rel="prefetch" href="/archived/assets/js/5.7048f9e2.js"><link rel="prefetch" href="/archived/assets/js/6.51e4d4fc.js"><link rel="prefetch" href="/archived/assets/js/7.43067d64.js"><link rel="prefetch" href="/archived/assets/js/8.09d20108.js"><link rel="prefetch" href="/archived/assets/js/9.c803c07c.js">
    <link rel="stylesheet" href="/archived/assets/css/0.styles.44ae0491.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/archived/" class="home-link router-link-active"><img src="/archived/favicon/favicon-32x32.png" alt="亿个本子" class="logo"> <span class="site-name can-hide">亿个本子</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/wmtdhe" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/wmtdhe" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Algorithm</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Networks</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Operation System</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Micellaneous</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/archived/miscellaneous/ecs-deployment.html" class="sidebar-link">ECS部署相关</a></li><li><a href="/archived/miscellaneous/browser-storage.html" class="sidebar-link">浏览器的本地存储</a></li><li><a href="/archived/miscellaneous/process.html" aria-current="page" class="active sidebar-link">从输入URL到页面呈现发生了什么</a></li><li><a href="/archived/miscellaneous/xss-csrf.html" class="sidebar-link">XSS和CSRF</a></li><li><a href="/archived/miscellaneous/reflow-repaint.html" class="sidebar-link">重排和重绘</a></li><li><a href="/archived/miscellaneous/cache.html" class="sidebar-link">浏览器缓存</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Practice</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="网络篇"><a href="#网络篇" class="header-anchor">#</a> 网络篇</h2> <h3 id="网络请求"><a href="#网络请求" class="header-anchor">#</a> 网络请求</h3> <h4 id="_1-构建请求"><a href="#_1-构建请求" class="header-anchor">#</a> 1.构建请求</h4> <p>浏览器会构建请求行：</p> <div class="language- extra-class"><pre class="language-text"><code>//请求方法是GET，路径是/，HTTP协议版本是1.1
GET / HTTP/1.1
</code></pre></div><h4 id="_2-查找强缓存"><a href="#_2-查找强缓存" class="header-anchor">#</a> 2.查找强缓存</h4> <p>先检查强缓存，如果命中直接使用，否则进入下一步。</p> <h4 id="_3-dns解析"><a href="#_3-dns解析" class="header-anchor">#</a> 3.DNS解析</h4> <p>由于我们输入的是域名，而数据包是通过<strong>IP地址</strong>传给对方的。因此我们需要得到域名对应的<strong>IP地址</strong>。这个过程需要以来一个服务系统，这个系统将域名和IP一一映射，我们将这个系统叫做<strong>DNS</strong>。得到具体IP地址的过场就是<strong>DNS解析</strong>。</p> <p>当然，浏览器提供了<strong>DNS数据缓存功能</strong>。即如果一个域名已经解析过，那会把解析的结果缓存下来，下次直接用缓存，不需要再经过DNS解析。</p> <p>另外，如果不指定端口的话，默认采用对应IP的80端口。</p> <h4 id="_4-建立tcp连接"><a href="#_4-建立tcp连接" class="header-anchor">#</a> 4.建立TCP连接</h4> <blockquote><p>TCP (Transmission Control Protocol, 传输控制协议)是一种面向连接、可靠的、基于字节流的传输层通信协议。</p></blockquote> <p>建立<strong>TCP连接</strong>经历了下面三个阶段：</p> <ol><li>通过<strong>三次握手</strong>建立客户端与服务端之间的连接。</li> <li>进行数据传输阶段。这里有一个重要机制，就是接收方收到数据包后必须要向发送方<strong>确认</strong>，如果发送方没有收到这个<strong>确认</strong>，就判定这个数据包丢失，并重新发送该数据包。在发送的过程中还有一个<strong>优化策略</strong>，就是<strong>把大的数据包拆成一个个小包</strong>，一次传输到接收方，接收方按照小包的顺序把他们组装成一个完成的数据包。</li> <li>断开连接的阶段。传输数据完成，就要断开连接了，通过<strong>四次挥手</strong>来断开连接。</li></ol> <p>到这里TCP连接的可靠性就通过：1.<strong>三次握手</strong>确认连接，2.<strong>数据包校验</strong>保证数据到达接收方，3.<strong>四次挥手</strong>断开连接 保证了。</p> <h4 id="_5-发送http请求"><a href="#_5-发送http请求" class="header-anchor">#</a> 5.发送HTTP请求</h4> <p><strong>TCP</strong>连接建立后，浏览器和服务端可以开始通信，即开始发送HTTP请求。浏览器发送HTTP请求要携带三样东西：<strong>请求行</strong>、<strong>请求头</strong>、<strong>请求体</strong>。</p> <p>首先，浏览器茴香服务器发送<strong>请求行</strong></p> <div class="language- extra-class"><pre class="language-text"><code>//请求方法GET 路径 / HTTP协议版本1.1
GET / HTTP/1.1
</code></pre></div><p>结构很简单，由请求方法、请求路径URI和HTTP版本协议组成。</p> <p>同时也要带上<strong>请求头</strong></p> <div class="language- extra-class"><pre class="language-text"><code>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
Cache-Control: no-cache
Connection: keep-alive
Cookie: /* 省略cookie信息 */
Host: www.baidu.com
Pragma: no-cache
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1
</code></pre></div><p>最后是请求体，只在<strong>POST</strong>方法下存在，常见场景是<strong>表单提交</strong></p> <h3 id="网络响应"><a href="#网络响应" class="header-anchor">#</a> 网络响应</h3> <p>HTTP请求到达服务器，服务器进行相应的处理。最后要把数据传给浏览器，也就是返回网络响应。</p> <p>跟请求部分类似，网络响应也分三个部分：<strong>响应行</strong>、<strong>响应头</strong>、<strong>响应体</strong>。</p> <p>响应行类似下面这样：</p> <div class="language- extra-class"><pre class="language-text"><code>HTTP/1.1 200 OK
</code></pre></div><p>由HTTP协议版本、状态码、状态描述组成。</p> <p>响应头包含了服务器及返回数据的一些信息，服务器生成数据的事件、返回的数据类型以及对即将写入的Cookie信息。
Example:</p> <div class="language- extra-class"><pre class="language-text"><code>Cache-Control: no-cache
Connection: keep-alive
Content-Encoding: gzip
Content-Type: text/html;charset=utf-8
Date: Wed, 04 Dec 2019 12:29:13 GMT
Server: apache
Set-Cookie: rsv_i=f9a0SIItKqzv7kqgAAgphbGyRts3RwTg%2FLyU3Y5Eh5LwyfOOrAsvdezbay0QqkDqFZ0DfQXby4wXKT8Au8O7ZT9UuMsBq2k; path=/; domain=.baidu.com
</code></pre></div><p>响应完后TCP一定就断开连接了吗？</p> <p>不一定。这时要判断<code>Connection</code>字段，如果请求头或响应头中包含<strong>Connection:Keep-Alive</strong>,表示建立了持久连接，这样TCP连接会一直保持，之后请求同一站点的资源会复用这个连接。</p> <p>否则断开TCP连接，请求-响应流程结束。</p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p><img src="https://user-gold-cdn.xitu.io/2019/12/15/16f080b095268038?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p> <h2 id="解析算法篇"><a href="#解析算法篇" class="header-anchor">#</a> 解析算法篇</h2> <p>完成了网络请求和响应后，如果响应头中<code>Content-Type</code>的值为<code>text/html</code>，那个接下来就是浏览器的<strong>解析</strong>和<strong>渲染</strong>工作了。</p> <p>首先来介绍解析部分，主要分为以下几个步骤：</p> <ul><li>构建<code>DOM</code>树</li> <li><code>css</code>计算</li> <li>生成<code>布局树（Layout tree）</code></li></ul> <h3 id="构建dom树"><a href="#构建dom树" class="header-anchor">#</a> 构建DOM树</h3> <p>由于浏览器无法直接理解<code>HTML字符串</code>，因此将这一系列的字节流转换为一种有意义并且方便操作的数据结构，这种数据结构就是<strong>DOM树</strong>。DOM树本质上是一个以<code>document</code>为根节点的多叉树。</p> <p>那到底是通过什么样的方式来进行解析的呢？</p> <h4 id="html文法的本质"><a href="#html文法的本质" class="header-anchor">#</a> HTML文法的本质</h4> <p><code>非上下文无关</code></p> <h4 id="解析算法"><a href="#解析算法" class="header-anchor">#</a> 解析算法</h4> <p>HTML5<a href="https://html.spec.whatwg.org/multipage/parsing.html" target="_blank" rel="noopener noreferrer">规范<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>详细地介绍了解析算法。这个算法分为两个阶段：</p> <ol><li>标记化</li> <li>建树</li></ol> <p>对应的两个过程就是<strong>词法分析</strong>和<strong>语法分析</strong>。</p> <h4 id="标记化算法"><a href="#标记化算法" class="header-anchor">#</a> 标记化算法</h4> <p>这个算法输入为<code>HTML文本</code>，输出为<code>HTML标记</code>，也称为<strong>标记生成器</strong>。其中运用<strong>有限自动状态机</strong>来完成。即在当前状态下，接受一个或多个字符，就会更新到下一个状态。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
     Hello
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>通过这个例子来演示一下<strong>标记化</strong>过程。</p> <p>遇到<code>&lt;</code>，状态为<strong>标记打开</strong></p> <p>接受<code>[a-z]</code>的字符，会进入<strong>标记名称状态</strong></p> <p>这个状态一直保持，直到遇到<code>&gt;</code>，表示名称记录完成，这时候变为<strong>数据状态</strong></p> <p>接下来遇到<code>body</code>标签做同样的处理</p> <p>这时候<code>html</code>和<code>body</code>的标记都做好了</p> <p>现在来到<code>&lt;body&gt;</code>中的<code>&gt;</code>，进<strong>入数据状态</strong>，之后保持这样的状态接收后面的字符<code>Hello</code></p> <p>接着接收<code>&lt;/body&gt;</code>中<code>&lt;</code>，回到<strong>标记打开</strong>，接收下一个<code>/</code>后，这时候会创建一个<code>end tag</code>的token</p> <p>随后进入<strong>标记名称状态</strong>，遇到<code>&gt;</code>回到<strong>数据状态</strong>。</p> <p>接着以同样的方式处理<code>&lt;/html&gt;</code></p> <h4 id="建树算法"><a href="#建树算法" class="header-anchor">#</a> 建树算法</h4> <p>之前提到过，DOM树是一个以<code>document</code>为根节点的多叉树。因此解析器首先会创建一个<code>document</code>对象。标记生成器会把每个标记的信息发送给<strong>建树器</strong>。<strong>建树器</strong>接收到相应的标记时，会创建<strong>对应的DOM对象</strong>。创建这个<code>DOM对象</code>后会做两件事情：</p> <ol><li>将<code>DOM对象</code>加入DOM树中</li> <li>将对应标记压入存放开放（与<code>闭合标签</code>意思对应）元素的栈中。</li></ol> <p>仍用这个例子说明：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
     Hello
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>首先，状态为<strong>初始化状态</strong></p> <p>接收到标记生成器传来的<code>html</code>标签，这时候状态变为<strong>before html状态</strong>。同时创建一个<code>HTMLHtmlElement</code>的DOM元素，将其加到<code>document</code>根对象上，并且进行压栈操作。</p> <p>接着状态自动变为<strong>before head</strong>，此时从标记生成器传来<code>body</code>，表示并没有<code>head</code>，这时候<strong>建树器</strong>会自动创建一个<code>HTMLHeadElement</code>并将其加入到DOM树。</p> <p>现在进入到<strong>in head</strong>状态，然后直接跳到<strong>after head</strong></p> <p>现在<strong>标记生成器</strong>传来了<code>body</code>标记，创建<code>HTMLBodyElement</code>，插入DOM树中，同时压入开放标记栈。</p> <p>接着状态变为<strong>in body</strong>,然后接收到后面的字符Hello，接收到第一个字符的时候，会创建一个<strong>Text</strong>节点并把字符插入其中，然后把<strong>Text</strong>节点插入DOM树中的<code>body元素</code>下面。随着不断的接收后面的字符，这些字符会附在<strong>Text</strong>节点上。</p> <p>现在，<strong>标记生成器</strong>传来一个<code>body</code>的结束标记，进入到<strong>after body</strong>状态</p> <p><strong>标记生成器</strong>最后传来一个<code>html</code>的结束标记，进入到<strong>after html</strong>状态，表示解析过程结束。</p> <h4 id="容错机制"><a href="#容错机制" class="header-anchor">#</a> 容错机制</h4> <p>参考神三元的<a href="https://juejin.im/post/5df5bcea6fb9a016091def69#heading-24" target="_blank" rel="noopener noreferrer">容错机制<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="样式计算"><a href="#样式计算" class="header-anchor">#</a> 样式计算</h3> <p>关于CSS样式，一般来源有三种：</p> <ol><li>link标签引用</li> <li>style标签中的样式</li> <li>元素的内嵌style</li></ol> <h4 id="格式化样式表"><a href="#格式化样式表" class="header-anchor">#</a> 格式化样式表</h4> <p>首先，浏览器是无法识别CSS样式文本的，因此渲染引擎接收到CSS文本之后第一件事情就是将其转化为一个结构化的对象，即<strong>styleSheets</strong>。</p> <p>这个格式化的过程过于复杂，而且对于不同浏览器会有不同的优化策略，这里就不展开了。</p> <p>在浏览器控制台中能够通过<code>document.styleSheets</code>来查看这个最终的结构。</p> <h4 id="标准化样式属性"><a href="#标准化样式属性" class="header-anchor">#</a> 标准化样式属性</h4> <p>有一些CSS样式的数值并不容易被渲染引擎理解，因此需要在计算样式之前将他们标准化，如 <code>em</code>-&gt;<code>px</code>,<code>red</code>-&gt;<code>#ff00000</code>,<code>bold</code>-&gt;<code>700</code>等等。</p> <h4 id="计算每个节点的具体样式"><a href="#计算每个节点的具体样式" class="header-anchor">#</a> 计算每个节点的具体样式</h4> <p>样式已经被<code>格式化</code>和<code>标准化</code>，接下来就可以计算每个节点的具体样式信息了。</p> <p>计算的方式主要有两个规则：<strong>继承</strong>和<strong>层叠</strong>。</p> <p>每个子节点都会默认继承父节点的样式属性，如果父节点中没有找到，就会采用浏览器默认样式，也叫<code>UserAgent样式</code>。这就是继承规则。</p> <p>然后是层叠规则，CSS最大的特点在于它的层叠性，也就是最终的样式取决于各个属性共同作用的效果，甚至有很多诡异的层叠现象。</p> <p>计算完样式后，所有的样式值都会被挂载到<code>window.getComputedStyle</code>当中，可以通过JS来获取到计算后的样式。</p> <h3 id="生成布局树"><a href="#生成布局树" class="header-anchor">#</a> 生成布局树</h3> <p>现在已经生成了<code>DOM树</code>和<code>DOM样式</code>，加下来要做的就是通过浏览器的布局系统<strong>确定元素的位置</strong>，也就是要生成一颗<strong>布局树</strong></p> <p>布局树生成大致工作如下：</p> <ol><li>遍历生成的DOM树节点，并把他们添加到<strong>布局树中</strong></li> <li>计算布局树节点的坐标位置</li></ol> <p>值得注意的是，这棵布局树只包含课件元素，对于<code>head</code>标签和设置了<code>display:none</code>的元素将不会被放入其中。</p> <h3 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> 总结</h3> <p><img src="https://user-gold-cdn.xitu.io/2019/12/15/16f080b2f718e4ad?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="页面解析计算过程"></p> <h2 id="渲染过程篇"><a href="#渲染过程篇" class="header-anchor">#</a> 渲染过程篇</h2> <p><strong>渲染</strong>主要分为以下几个步骤：</p> <ol><li>建立<code>图层树（layer tree）</code></li> <li>生成<code>绘制列表</code></li> <li>生成<code>图块</code>并<code>栅格化</code></li> <li>显示器显示内容</li></ol> <h3 id="_1-建图层树"><a href="#_1-建图层树" class="header-anchor">#</a> 1. 建图层树</h3> <p>如果你觉得现在<strong>DOM节点</strong>有了，样式，位置也有了就可以开始绘制页面了，那你就错了。</p> <p>因为你考虑掉了另外一些复杂的场景，比如3D动画如何呈现出变换效果，当元素含有层叠上下文时如何控制显示和隐藏等等。</p> <p>为了解决如上所述的问题，浏览器在构建完<strong>布局树</strong>之后，还会对特定的节点进行分层，构建一棵<strong>图层树(layer tree)</strong>。</p> <p>图层树是根据什么来构建的呢？</p> <p>一般情况下，节点的图层会默认属于父节点的图层。那什么时候会提升为一个单独的图层（也称为<strong>合成层</strong>）呢</p> <p>有两种情况需要分别讨论：一是<strong>显式合成</strong>，而是<strong>隐式合成</strong>。</p> <h4 id="显式合成"><a href="#显式合成" class="header-anchor">#</a> 显式合成</h4> <p>显式合成情况：</p> <p>一、拥有<strong>层叠上下文</strong>的节点</p> <p>层叠上下文也基本上是有一些特定的CSS属性创建的，一般有以下情况：</p> <ol><li>HTML根元素本身就有层叠上下文</li> <li>普通元素设置<code>position</code>不为<code>static</code>并且设置了<code>z-index</code>，会产生层叠上下文。</li> <li>元素<code>opacity</code>不会1</li> <li>元素<code>transform</code>不为none</li> <li>元素<code>filter</code>不会none</li> <li>元素<code>isolate</code>的值为isolate</li> <li><code>will-change</code>指定的属性值为上面任意一个。</li></ol> <p>二、需要<strong>裁减</strong>的地方</p> <p>比如一个div，只给了100*100的长宽大小，而里面的文字放了很多，那么超出的部分就要被裁减掉。当然如果出现了滚动条，那么滚动条会被单独提升为一个图层。</p> <h4 id="隐式合成"><a href="#隐式合成" class="header-anchor">#</a> 隐式合成</h4> <p>接下来是<code>隐式合成</code>，简单来说就是<code>层叠等级低</code>的节点被提升为单独的图层之后，那么<strong>所有层级等级比它高</strong>的节点都会成为一个单独的图层。</p> <h3 id="_2-生成绘制列表"><a href="#_2-生成绘制列表" class="header-anchor">#</a> 2.生成绘制列表</h3> <p>接下来渲染引擎会把图层的绘制拆分成一个个绘制指令，比如先画背景、再描绘边框。。。然后将这些指令按顺序组合成一个待绘制列表，相当于给后面的绘制操作做了一波计划。</p> <h3 id="_3-生成图块和生成位图"><a href="#_3-生成图块和生成位图" class="header-anchor">#</a> 3.生成图块和生成位图</h3> <p>现在开始绘制操作，实际上在渲染进程中绘制操作是由专门的线程来完成的，这个线程叫<strong>合成线程</strong>。</p> <p>因为视口就那么大，当页面很大时，要很久才滑到底，如果一口气绘制完很消耗性能。因此合成线程会把图层<strong>分块</strong></p> <h3 id="_4-显示器显示内容"><a href="#_4-显示器显示内容" class="header-anchor">#</a> 4. 显示器显示内容</h3> <h3 id="总结-3"><a href="#总结-3" class="header-anchor">#</a> 总结</h3> <p><img src="https://user-gold-cdn.xitu.io/2019/12/15/16f080b7b8926b7f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/archived/miscellaneous/browser-storage.html" class="prev">
        浏览器的本地存储
      </a></span> <span class="next"><a href="/archived/miscellaneous/xss-csrf.html">
        XSS和CSRF
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/archived/assets/js/app.8b58d644.js" defer></script><script src="/archived/assets/js/2.bf33e473.js" defer></script><script src="/archived/assets/js/31.22830e2f.js" defer></script>
  </body>
</html>
